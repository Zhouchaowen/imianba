# TCP

## 1.是什么

**面向连接的,提供端到端可靠性服务**的传输层协议。

> 什么叫面向链接？

在传输数据前，会在**两个端点**之间建立了一条**可靠的**数据通信信道。

> 为什么是可靠的？

保证从发送端发送的报文都可以被目的端收到，哪怕被丢弃，也可以让发送端重传;

> 还有那些传输层协议？

UDP

FTP

## 2.为什么

IP 层是「**不可靠**」的，它只负责数据包的发送，但它不保证数据包能够被接收、不保证网络包的按序交付、也不保证网络包中的数据的完整性。如果需要**保障网络数据包的可靠性**，那么就需要**由上层（传输层）的 TCP 协议来负责**。

因为 TCP 是一个工作在**传输层**的**可靠**数据传输的服务，它能确保接收端接收的网络包是**无损坏、无间隔、非冗余和按序的。**

在了解TCP连接之前先来了解一下TCP报文的头部结构。

![](https://pic4.zhimg.com/v2-2aa192d35fb785d6ff699035d060dc47_r.jpg)

**如何确保可靠传输？**

### 链接管理

> 三次握手





> 四次挥手







### 确认应答

确认应答机制就是接收方收到 TCP 报文段后就会返回**一个确认应答消息**：

### 序列号



### 校验和

由发送端计算待发送 TCP 报文段的校验和，然后接收端对接收到的 TCP 报文段验证其校验和（TCP 的校验和是一个端到端的校验和）。其目的是为了发现 TCP 的首部和数据在发送端到接收端之间是否发生了变动。如果接收方检测到校验和有差错，则该 TCP 报文段会被直接丢弃。

### 重传

- 超时重传
- 快速重传

在错综复杂的网络，并不一定能如上图那么顺利地传输报文，报文存在丢失的可能性。报文丢失的可能因素有很多种，包括应用故障，路由设备过载，或暂时的服务宕机。报文级别速度是很高的，通常来说报文的丢失是暂时的，因此 TCP 能够发现和恢复报文丢失显得尤为重要。

超时重传就是 TCP 发送方在发送报文的时候，设定一个定时器，如果在规定的时间内没有收到接收方发来的 ACK 确认报文，发送方就会重传这个已发送的报文段。

对于发送方没有正确接收到接收方发来的 ACK 确认报文的情况，有以下两种

- 第一种情况：报文段丢失
- 第二种情况：接收方的 ACK 确认报文丢失

超时重传时间我们一般用 RTO（Retransmission Timeout） 来表示，那么，这个 RTO 设置为多少最合适呢，也就是说经过多长时间进行重传最好？

在这之前，我们先讲解一下 RTT（Round-Trip Time 往返时延） 的概念：RTT 就是数据从网络一端传送到另一端所需的时间，也就是报文段的往返时间。

---

快速重传（Fast Retransmit）机制不以时间为驱动，而是以数据驱动重传。

快速重传机制的原理：每当接收方收到比期望序号大的失序报文段到达时，就向发送方发送一个冗余 ACK，指明下一个期待字节的序号。

举个例子：发送方已经发送 1、2、3、4、5报文段

- 接收方收到报文段 1，返回 1 的 ACK 确认报文（确认号为报文段 2 的第一个字节）
- 接收方收到报文段 3，仍然返回 1 的 ACK 确认报文（确认号为报文段 2 的第一个字节）
- 接收方收到报文段 4，仍然返回 1 的 ACK 确认报文（确认号为报文段 2 的第一个字节）
- 接收方收到报文段 5，仍然返回 1 的 ACK 确认报文（确认号为报文段 2 的第一个字节）
- 接收方收到 3 个对于报文段 1 的冗余 ACK，认为报文段 2 丢失，于是重传报文段 2
- 最后，接收方收到了报文段 2，此时因为报文段 3、4、5 都收到了，所以返回 6 的 ACK 确认报文（确认号为报文段 6 的第一个字节）

![](https://pic2.zhimg.com/80/v2-17dd3b71de595378c691ae1dad052001_720w.jpg)



### 滑动窗口

收到了上一个报文段的确认应答后才能发送下一个报文段的这种模式效率非常低下。每个报文段的往返时间越长，网络的吞吐量就越低，通信的效率就越低。

举个例子：如果你说完一句话，我在处理其他事情，没有及时回复你，你就等着我做完其他事情后回复你，你才能说下一句话，很显然这不现实。

为此，TCP 引入了 窗口 的概念。窗口大小就是指无需等待确认应答，可以继续发送数据的最大值。

 窗口的实现实际上是操作系统开辟的一个缓冲区，发送方在等待确认应答报文返回之前，必须在缓冲区中保留已发送的数据。如果在规定时间间隔内收到确认应答报文，就可以将数据从缓冲区中清除。

假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途即使有 ACK响应报文丢失，也可以通过「下一个确认应答进行确认」。

如下图：ACK 300 即使丢失了，也不会进行数据重发，可以通过下一个确认应答进行确认。只要发送方收到了 ACK 400 的确认应答，就意味着 400 之前的所有数据「接收方」都收到了。这个模式就叫累积确认或者累积应答。

![](https://pic3.zhimg.com/80/v2-61957f3a61bc7ef342e6e39496bc010a_720w.jpg)



### 流量控制

主机 A 一直向主机 B 发送数据，不考虑主机 B 的接收能力，则可能导致主机 B 的接收缓冲区满了而无法再接收数据，从而导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机 B 的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。

所以引入了流量控制机制，主机 B 通过告诉主机 A 自己接收缓冲区的大小，来使主机 A 控制发送的数据量。总结来说：所谓流量控制就是控制发送方发送速率，保证接收方来得及接收。



### 拥塞控制

在某段时间，对网络中某一资源的需求超过了该资源所能提供的可用部分（即 需大于供)，网络的性能变差。

如果网络出现拥塞，TCP 报文可能会大量丢失，此时就会大量触发重传机制，从而导致网络拥塞程度更高，严重影响传输。

流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度，防止过多的数据注入到网络中。

为了调节发送方所要发送数据的量，定义了「拥塞窗口 cwnd」的概念。拥塞窗口是发送方维护的一个状态变量，它会根据网络的拥塞程度动态变化：

- 只要网络中出现了拥塞，cwnd 就会减少
- 若网络中没有出现拥塞，cwnd 就会增大

在引入拥塞窗口概念之前，发送窗口大小和接收窗口大小基本是相等的关系（取决于接收窗口大小）。引入拥塞窗口后，发送窗口的大小就等于拥塞窗口和接收窗口的最小值。

TCP 的拥塞控制采用了四种算法：

- 慢开始
- 拥塞避免
- 快重传
- 快恢复

慢开始的思路就是：TCP 在刚建立连接完成后，如果立即把大量数据字节注入到网络，那么很有可能引起网络阻塞。好的方法是先探测一下，一点一点地提高发送数据包的数量，即由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍（指数增长）。

![img](https://pic3.zhimg.com/80/v2-ca4ad54df31db6fec7fd58457dba3382_720w.jpg)

当然不能一直执行慢启动，这里会设置一个慢启动轮限 ssthresh 状态变量：

- 当 cwnd < ssthresh 时，继续使用慢启动算法
- 当 cwnd >= ssthresh 时，开始使用「拥塞避免算法」

拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 cwnd 加 1。

![img](https://pic2.zhimg.com/80/v2-bd8680ba88931bfbe8b89169b09cc605_720w.jpg)

注意，无论是慢开始阶段还是拥塞避免，只要出现了网络拥塞（触发超时重传机制），慢开始轮限 sshresh 和 拥塞窗口大小 cwnd 的值会发生变化（乘法减小）：

- ssthresh 设为 cwnd/2
- cwnd 重置为 1

由于拥塞窗口大小重置为 1 了，所以就会重新开始执行慢启动算法。

![img](https://pic1.zhimg.com/80/v2-742a4947b97ea6deb89d58f69d2f8810_720w.jpg)



快速重传和快速恢复算法一般同时使用。

当触发快速重传机制，即接收方收到三个重复的 ACK 确认的时候，就会执行快重传算法（触发快速重传机制和超时重传机制的情况不同，TCP 认为触发快速重传的情况并不严重，因为大部分没丢，只丢了一小部分），快速重传做的事情有：

- cwnd = cwnd/2
- ssthresh = cwnd
- 重新进入拥塞避免阶段

后来的 “快速恢复” 算法是在上述的“快速重传”算法后添加的，当收到 3 个重复ACK时，TCP 最后进入的不是拥塞避免阶段，而是快速恢复阶段。

快速恢复的思想是“**数据包守恒**”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一 个“新”的数据包，如果发送方收到一个重复的 ACK，那么根据 TCP 的 ACK 机制就表明有一个数据包离开了网络，于是 cwnd 加 1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。

具体来说快速恢复的主要步骤是：

- 把 cwnd 设置为 ssthresh 的值加 3，然后重传丢失的报文段，加 3 的原因是因为收到 3 个重复的 ACK，表明有 3 个“老”的数据包离开了网络。
- 再收到重复的 ACK 时，拥塞窗口 cwnd 增加 1
- 当收到新的数据包的 ACK 时，把 cwnd 设置为第一步中的 ssthresh 的值。原因是因为该 ACK 确认了新的数据，说明从重复 ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。

![img](https://pic1.zhimg.com/80/v2-2b7564e5af3e189a137d50125231f50c_720w.jpg)

### 数据分块







## 3.怎么用























# 参考

https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F

https://www.zhihu.com/question/51074319

https://www.itprc.com/tcpipfaq/

https://www.ionos.com/digitalguide/server/know-how/introduction-to-tcp/

https://www.bilibili.com/video/BV1JV411t7ow

https://blog.csdn.net/qzcsu/article/details/72861891

https://zhuanlan.zhihu.com/p/53374516

https://zhuanlan.zhihu.com/p/343398180

https://www.zhihu.com/question/24853633/answer/115173386

https://zhuanlan.zhihu.com/p/133307545

https://zhuanlan.zhihu.com/p/147370653

https://zhuanlan.zhihu.com/p/339237818

https://zhuanlan.zhihu.com/p/30032980